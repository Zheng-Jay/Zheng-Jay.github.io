<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>burp suit使用指南</title>
    <url>/20211122/burp%20suit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="burp-suit"><a href="#burp-suit" class="headerlink" title="burp suit"></a>burp suit</h1><h2 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h2><p><code>开代理</code></p>
<h2 id="发送get"><a href="#发送get" class="headerlink" title="发送get"></a>发送get</h2><p>修改请求类型，加入参数。</p>
<p><img src="../../../备份/images/burp suit使用指南/burpsuit_Get.png" alt=""></p>
<h2 id="发送POST"><a href="#发送POST" class="headerlink" title="发送POST"></a>发送POST</h2><p>修改请求类型，加入<code>Content-Type: application/x-www-form-urlencoded</code>。</p>
<p>然后再<code>空一行</code>，再加入参数。</p>
<p>Conent-Type:请求体中的内容类型，在上述参数中，代表请求的内容将会使用url编码。</p>
<p><img src="../../../备份/images/burp suit使用指南/burpsuit_Post.png" alt=""></p>
<p>特别注意：无论是发送get请求，还是post请求，<code>报文的最后都要空两行</code>！</p>
]]></content>
      <categories>
        <category>笔记&#39;</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ctf</tag>
        <tag>web</tag>
        <tag>burp suit</tag>
      </tags>
  </entry>
  <entry>
    <title>it英语</title>
    <url>/20211119/it%E8%8B%B1%E8%AF%AD.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><p>deploy[dɪˈplɔɪ] vt 部署，调度，安排</p>
<p>download vt 下载</p>
<p>upload vt 上传</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf文件上传</title>
    <url>/20211122/ctf%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h1><p>最简单的文件校验是<code>本地js校验</code>，一般都是要求只能上传jpg，png，gif<code>图片格式</code>：</p>
<p><img src="https://i.loli.net/2021/11/15/lhFPZ1RdmijMBab.jpg" alt="本地校验.jpg"></p>
<p>应对措施：在本地<code>禁用js</code>。</p>
<p><img src="https://i.loli.net/2021/11/15/ib1trSMOZ2sVvH3.jpg" alt="本地禁用js.jpg"></p>
<h1 id="服务端校验"><a href="#服务端校验" class="headerlink" title="服务端校验"></a>服务端校验</h1><p>服务端校验比较棘手一点。</p>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><h3 id="常用php函数"><a href="#常用php函数" class="headerlink" title="常用php函数"></a>常用php函数</h3><h4 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h4><p><code>trim(string,charlist)</code>移除字符串两侧的字符,ltrim()和rtrim()则分别是移除字符串左右侧的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span> . PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> trim(<span class="variable">$str</span>,<span class="string">&quot;Hed!&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#Hello World!</span></span><br><span class="line"><span class="comment">#llo Worl</span></span><br></pre></td></tr></table></figure>
<h4 id="strrchr"><a href="#strrchr" class="headerlink" title="strrchr()"></a>strrchr()</h4><p><code>strrchr(string,char)</code>，该函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该字符串开始到末尾的字符串。</p>
<h4 id="str-ireplace"><a href="#str-ireplace" class="headerlink" title="str_ireplace()"></a>str_ireplace()</h4><p><code>str_ireplace(find,replace,string,count)</code>，该函数替换字符串中的一些字符（不区分大小写）。</p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p><a href="https://blog.csdn.net/weixin_42250835/article/details/119444097?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-119444097.pc_agg_new_rank&amp;utm_term=%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%90%8E%E7%BC%80%E9%BB%91%E5%90%8D%E5%8D%95&amp;spm=1000.2123.3001.4430">修改后缀绕过</a></p>
<p>文件的修改不用在本地修改，抓包修改即可。</p>
<h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><p>若把大小写、空格、点等都过滤了，则考虑其他办法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_ext</span> = str_ireplace(<span class="variable">$blacklist</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file_ext</span>);</span><br></pre></td></tr></table></figure>
<p><code>str_ireplace()</code>只会替换一次，所以可以构造<code>a.pphphp</code>文件名，执行后变为<code>a.php</code>。</p>
<h2 id="MIME类型校验"><a href="#MIME类型校验" class="headerlink" title="MIME类型校验"></a>MIME类型校验</h2><p>虽然我们在客户端同过禁用js上传了文件，但服务端还会再对文件类型进行校验，并且校验的是<code>MIME</code>。</p>
<p><img src="https://i.loli.net/2021/11/15/WkGHwtmN9fFpuzc.jpg" alt="MIME校验.jpg"></p>
<p>我们在开发者工具中，虽然看到文件发送成功:</p>
<p><img src="https://i.loli.net/2021/11/15/qtRHP2394MosFJB.jpg" alt="文件上传成功.jpg"></p>
<p>但如果服务端对我们请求的数据中的MIME类型进行校验，发现并非image类型，仍会丢弃。</p>
<p>所以，我们要修改请求包中的MIME类型（使用burp suit），常见的MIME类型：</p>
<p><img src="https://i.loli.net/2021/11/15/cYKwPhJZ7xpVuQk.jpg" alt="MIME类型.jpg"></p>
<p>修改MIME类型：</p>
<p><img src="https://i.loli.net/2021/11/15/Dc1YzT7FMsRifLv.jpg" alt="修改MIME类型.jpg"></p>
<h2 id="文件头校验"><a href="#文件头校验" class="headerlink" title="文件头校验"></a>文件头校验</h2><p>有些题目中，服务端还会对上传的<code>文件头</code>进行校验，如果我们的文件头非图片格式，依然会被舍弃。</p>
<p>这时，我们就要用到<code>图片码</code>了！</p>
<p>在windos中，我们可以在cmd中用<code>copy</code>将文件进行捆绑。</p>
<p>我们只要将一张png图片和我们的php文件捆绑，不就有了png文件头，绕过服务端的校验了吗？</p>
<p><code>copy 1.png/b+2.php give_me_flag.php</code></p>
<p>照着这条指令，将文件进行修改就行了。</p>
<p>在用这条指令的时候，要注意<code>关闭windows自带的病毒防护</code>，不然会将一句话木马文件清掉。</p>
<p><img src="https://i.loli.net/2021/11/15/L8l3kbuGU1WpymD.jpg" alt="图片码.jpg"></p>
<h2 id="后缀黑名单校验"><a href="#后缀黑名单校验" class="headerlink" title="后缀黑名单校验"></a>后缀黑名单校验</h2><p>在参考资料中，还看到服务端有这种校验，但笔者还未遇到，等遇到了再记录。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_40657585/article/details/83792824">一句话图片码</a></p>
<p><a href="https://www.aqniu.com/vendor/54889.html">文件上传</a></p>
]]></content>
      <categories>
        <category>ctfWeb</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
        <tag>F12开发者工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/20211119/my-first-blog.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>​    这是我的第一篇blog，折腾了两天，虽然还有很多设置没有弄完，但个人blog算初步建成了吧。</p>
<p>​    这里不仅将像CSDN一样，些一些技术文章，还将记录一些生活blog，像是小说读后感啊，随笔啊，吐槽啊……</p>
<p>​    对了，差点忘了说写个人blog的目的。</p>
<p>​    一个原因是想要拥有自己的一片创作天地，记录自己的点滴，让自己能够坚持学习下去，另外，要写技术性文章，就必须把技术的原理、应用各方面都讲清楚，那这也可以促进自己的学习和表达能力。</p>
<p>​    另外一个原因，说来有点可笑。听说在应聘的时候，有些面试官要看应聘者的能力，会看应聘者平时有没有写文章，在github都保存些什么代码。听说，有的人就是在知乎等社交平台不断推广自己的文章，为自己引流，塑造技术大牛的形象，从而为自己增分的。</p>
<p>​    我想，或许我也来搞一个，不求高热度，只要能帮到自己，帮到别人就够了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>noteC&amp;C++</title>
    <url>/20211119/noteC&amp;C++.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数传二维数组"><a href="#函数传二维数组" class="headerlink" title="函数传二维数组"></a>函数传二维数组</h1><p><a href="https://blog.csdn.net/fireflylane/article/details/84097611">参考资料</a></p>
<h2 id="必须指定高维的大小"><a href="#必须指定高维的大小" class="headerlink" title="必须指定高维的大小"></a>必须指定高维的大小</h2><p>在传参的时候，<code>第一维的大小可用不指定，但必须指定第二维的大小。</code></p>
<p>原因：实参传递进来的实际上是一个<code>指针</code>，指向数组的起始地址，在内存中，所有的元素都是<code>线性排列</code>的，并不区分行列，若不指定高维大小，则系统无法知道该数组每一维的大小。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>该例子一维和二维的大小都指定了，但一维大小可以省略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> Available[NumPro][NumSrc])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> (*work)[NumSrc] = Available;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传递进来的是指针"><a href="#传递进来的是指针" class="headerlink" title="传递进来的是指针"></a>传递进来的是指针</h2><p>注意：传递进来的是指针，在函数内，若将该指针赋值给一个变量，然后再在该变量指向的内存上进行修改，<code>原数组将会被修改到</code>。</p>
<p>解决的方法是，将数组<code>复制</code>给一个新的数组，例如，对于上面的例子，我们将Available复制给work：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> Available[NumPro][NumSrc])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> (*work)[NumSrc] = Available;</span><br><span class="line">    <span class="comment">//对数组进行拷贝，并且修改拷贝后的数组元素的值</span></span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumPro; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NumSrc; j++) &#123;</span><br><span class="line">				work[i][j] = Available[i][j];</span><br><span class="line">				work[i][j] ++;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;work[%d][%d]:%d\n&quot;</span>, i, j, work[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//验证对复制后的数组进行修改后，原数组是否发生改变</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumPro; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NumSrc; j++) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;work2[%d][%d]:%d\n&quot;</span>, i, j, Available[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>noteCMD</title>
    <url>/20211119/noteCMD.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查看当前目录的文件和文件夹"><a href="#查看当前目录的文件和文件夹" class="headerlink" title="查看当前目录的文件和文件夹"></a>查看当前目录的文件和文件夹</h1><p>dir</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>noteGit</title>
    <url>/20211122/noteGit.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">廖雪峰教程</a></p>
<p><a href="https://www.runoob.com/git/git-basic-operations.html">菜鸟教程</a></p>
<h1 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h1><p>Linux之父Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！</p>
<h1 id="Git的优点"><a href="#Git的优点" class="headerlink" title="Git的优点"></a>Git的优点</h1><p>GIt是分布式版本控制系统，是程序猿协同合作的利器。跟集中式版本控制系统相比，有如下优势：</p>
<p>·工作时无需联网。在集中式中，用户需要先从中央服务器下载文件再进行修改，而在分布式中，每个人的电脑都是一个完整的版本库。</p>
<p>·安全性更高。即使用户的电脑损坏了，要获取原来的版本库，只需要从协作者那里copy一份即可。</p>
<p>·Git如何实现协同合作？</p>
<p>对方只要把他对文件的修改发送给我们，我们在本地的版本库中对文件进行修改即可。</p>
<h1 id="GIthub"><a href="#GIthub" class="headerlink" title="GIthub"></a>GIthub</h1><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>而github网站就算提供git仓库托管服务的。</p>
<p>github支持多种协议，给出的仓库url不止一个，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p><img src="../../../备份/images/noteGit/不同协议.png" alt=""></p>
<h1 id="Github仓库地址"><a href="#Github仓库地址" class="headerlink" title="Github仓库地址"></a>Github仓库地址</h1><p><img src="D:\myblog\备份\images\noteGit\仓库地址.png" alt=""></p>
<p>ssh地址格式：<a href="mailto:`git@github.com">`git@github.com</a>:[user-name]/[repository-name].git`</p>
<h1 id="Github为何需要SSH-KEY？"><a href="#Github为何需要SSH-KEY？" class="headerlink" title="Github为何需要SSH-KEY？"></a>Github为何需要SSH-KEY？</h1><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<h1 id="Git的局限性"><a href="#Git的局限性" class="headerlink" title="Git的局限性"></a>Git的局限性</h1><p>Git只能记录文本文件的改动：</p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>也就是当前目录，文件从工作区添加到暂存区。</p>
<h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p><code>.git</code>文件就是版本库。</p>
<p>版本库里存了很多东西，最重要的有<code>暂存区</code>（stage或index），以及系统为我们自动创建的第一个<code>分支master</code>、指向master的一个指针<code>HEAD</code>。</p>
<h2 id="master和HEAD"><a href="#master和HEAD" class="headerlink" title="master和HEAD"></a>master和HEAD</h2><p>两者都是指针。</p>
<p>在提交版本的时候，git会将所有的版本串成一条<code>时间线</code>，这条<code>时间线就是一个分支</code>。master分支就是一条时间线，<code>master指向最新的提交</code>。</p>
<p><code>HEAD指向的是当前分支</code>。</p>
<p>知道了HEAD和master，系统就知道命令要处理的是哪个分支的哪个提交了。</p>
<p><img src="D:\myblog\备份\images\noteGit\master&amp;HEAD.png" alt=""></p>
<h1 id="Git指令"><a href="#Git指令" class="headerlink" title="Git指令"></a>Git指令</h1><h2 id="本地基本指令"><a href="#本地基本指令" class="headerlink" title="本地基本指令"></a>本地基本指令</h2><p>本地仓库初始化：<code>git init</code></p>
<p>执行完该命令，系统会在当前目录生成一个<code>.git</code>文件夹，该文件夹一般是隐藏的。</p>
<p>查看隐藏文件：<code>ls -ah</code>。</p>
<p><code>添加文件</code>到缓冲区：<code>git add .</code>，这个命令是把当前目录的所有文件都添加到缓冲区，也可以指定某个文件。</p>
<p>将文件<code>提交</code>到仓库：<code>git commit -m &quot;your message&quot;</code>，实际上，就是添加到分支当中。这个命令的参数<code>-m</code>让用户提交时留下能够留下说明。据说在网上有办法让我们使用commit命令时不用提交说明，但是不建议这样做。</p>
<p><img src="D:\myblog\备份\images\noteGit\add&amp;commit.jpg" alt=""></p>
<p>在提交之前，查看状态：<code>git status</code></p>
<p><img src="D:\myblog\备份\images\noteGit\git status.png" alt=""></p>
<p>可以看到，我们修改了’readme.txt’这个文件，同时，在下面一行可以知道，我们未<code>add</code>任何修改。</p>
<p>查看文件的修改情况：<code>git diff readme.txt</code></p>
<p><img src="D:\myblog\备份\images\noteGit\git diff.png" alt=""></p>
<p>个人理解，那个a代表暂存区的文件，b代表工作区的文件。</p>
<p>再看下面，<code>a</code>的前面有<code>三个-</code>，以及下面有<code>abcdefg</code>，这并不代表对内容删去，只是代表暂存区文件而已，而<code>+</code>代表工作区文件。</p>
<p>红色代表暂存区文件文本，绿色代表工作区的，对比一下，就可以知道，我们在文本末添加了<code>h</code>。</p>
<p>若修改都提交了，则将无回显。</p>
<p>查看版本系统历史记录（顺序：由近到远）：<code>git log</code></p>
<p>如果嫌信息太多，可以用：<code>git log --pretty=online</code>，省略作者、日期，但会保留<code>commit id（版本号）</code>和commit message。</p>
<p>版本回退一次：<code>git reset --hard HEAD^</code></p>
<p>按版本号回退：<code>git reset --hard commitid</code></p>
<p>查看输入的每一条命令（包含所有的版本号）：<code>git reflog</code></p>
<p>对单个文件的修改进行撤销：<code>git checkout -- file</code>，该命令能够将file返回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>从版本库中删除某个文件：<code>git rm file</code>，随后，要<code>git commit</code></p>
<p>若本地误删了文件，可以从版本库中进行恢复：<code>git checkout -- file</code>，<code>git checkout</code>的作用是用版本库里的版本替换工作区的版本。</p>
<p>删除本地仓库：<code>find . -name &quot;.git&quot; | xargs rm -Rf</code></p>
<p><a href="https://blog.csdn.net/wq6ylg08/article/details/88789501">参考资料</a></p>
<h2 id="远程命令"><a href="#远程命令" class="headerlink" title="远程命令"></a>远程命令</h2><p>关联远程库：<code>git remote add origin https://github.com/Zheng-Jay/Zheng-Jay.github.io.git</code></p>
<p>关联后，远程库的名字就是<code>origin</code>，这是默认叫法。</p>
<p>git push命令格式：<code>git push 远程主机名 本地分支名:远程分支名</code></p>
<p>将当前<code>master分支</code>推送到远程库的master分支：<code>git push origin master</code></p>
<p>廖雪峰和github在第一次提交时，用的是<code>git push -u origin master</code>，加入<code>-u</code>的作用是除推送到远程外，还会把本地的master分支和远程的master分支关联起来，这样在以后的拉取和推送时就可以简化命令，可以直接用<code>git push</code>代替<code>git push origin master</code>。</p>
<p>此时，远程主机是<code>origin</code>，本地分支是<code>master</code>，由于远程分支名和本地分支相同，故省略。</p>
<p>若想push到远程的save分支，应这样写：<code>git push origin master:save</code></p>
<p>clone远程库：<code>git clone https://github.com/ipyker/hexo-next-theme</code></p>
<p>查看远程库信息：<code>git remote -v</code></p>
<p>与远程库解绑（此处实例为origin）：<code>git remote rm origin</code></p>
<p>分支重新命名（将当前分支命名为<code>main</code>，该命令出现在github初始化仓库中）：</p>
<p><code>git branch -M main</code></p>
<h2 id="分支创建、查看与切换"><a href="#分支创建、查看与切换" class="headerlink" title="分支创建、查看与切换"></a>分支创建、查看与切换</h2><p>创建并切换（加上<code>-b</code>参数)：<code>git checkout -b dev</code>，该命令相当于以下两条命令：</p>
<p><code>git branch dev</code>+<code>git checkout dev</code></p>
<p>查看所有分支：<code>git branch</code></p>
<p>切换到dev分支后，此时再提交文件，将不会影响master分支：</p>
<p><img src="D:\myblog\备份\images\noteGit\newBranch.png" alt=""></p>
<p>git鼓励用户创建新分支完成某个任务，然后再合并分支并删除，这和直接在master分支上工作效果是一样的，但过程更安全（试想如果master分支是由一个10人的团队共同维护的）。</p>
<p>合并指定分支到当前分支：<code>git merge dev</code></p>
<p>用该命令进行合并，会显示<code>Fast-forward</code>，该合并模式为<code>快进模式</code>，就是直接将master指向dev的当前提交，速度非常快。</p>
<p>合并完之后，并可<code>删除dev分支</code>：<code>git branch -d dev</code></p>
<p>由于前面用<code>chectout</code>既进行了撤销修改，又进行了分支切换，导致该命令有点难以理解，故推荐使用<code>switch</code>进行分支切换。</p>
<p>创建并切换到新的<code>dev</code>分支：<code>git switch -c dev</code></p>
<p>直接切换到已有分支：<code>git switch master</code></p>
<p>其他命令：</p>
<p><img src="D:\myblog\备份\images\noteGit\分支命令.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>noteJava</title>
    <url>/20211122/noteJava.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h1><p>单引号的数据是char类型，双引号是String数据。</p>
<p>用单引号的时候，有时会遇到这种奇怪的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">4</span> + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(<span class="number">4</span> + <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">System.out.println(<span class="number">3</span> + <span class="string">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4,</span><br><span class="line">48</span><br><span class="line">47</span><br></pre></td></tr></table></figure>
<h1 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h1><p><a href="https://zhidao.baidu.com/question/327948017.html">参考资料</a></p>
<p>整数的：<code>Integer.MAX_VALUE</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="系统数组"><a href="#系统数组" class="headerlink" title="系统数组"></a>系统数组</h2><p>定义：数组是指一组数据的<code>集合</code>，数组中的每个数据被称作<code>元素</code>。在数组中，可以存放<code>任意类型</code>的元素，但同一数组里只能存放<code>同一类型</code>的元素。</p>
<p>数组类型：int、String、Object</p>
<p>分类：一维数组和多维数组。</p>
<p>局限：数组的长度在定义的时候就确定了。</p>
<p>定义数组的语法格式：</p>
<p><img src="../../../备份/images/noteJava/数组语法格式.png" alt=""></p>
<p>注意：java的数组元素是放在大括号。</p>
<p>基本操作：数组的遍历、最值的获取、数组的排序等。</p>
<h2 id="数组和列表的区别"><a href="#数组和列表的区别" class="headerlink" title="数组和列表的区别"></a>数组和列表的区别</h2><p><a href="https://www.cnblogs.com/yanyufeng/p/9852299.html">参考博客</a></p>
<p>根据网上的说法，数组和列表有两点不同（这个说法是否适用于所有语言有待考证）：</p>
<p>1、数组的长度是不可变的，在定义时就已经确定。而列表的长度是可以动态改变的。</p>
<p>2、数组内存放的元素数据类型必须相同，列表则没有这个硬性要求。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较两个数组是否相同</span></span><br><span class="line"><span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最值</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.stream(nums).min().getAsInt();</span><br></pre></td></tr></table></figure>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><a href="https://www.cnblogs.com/lighten/tag/Java%E4%B9%8B%E9%9B%86%E5%90%88/default.html?page=2">参考资料</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>集合跟系统数组一样，可以存储任意类型的数据，同时，还能补充系统数组的缺陷，可以动态修改数组长度。集合有很多类，这些类全部放在<code>java.util</code>包中。</p>
<p><img src="../../../备份/images/noteJava/集合体系核心结构.png" alt=""></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="单列集合Collection"><a href="#单列集合Collection" class="headerlink" title="单列集合Collection"></a>单列集合Collection</h3><p>单列集合根接口，用于存储一系列符合某种规则的元素。</p>
<p>主要方法：</p>
<p><img src="../../../备份/images/noteJava/collection主要方法.png" alt=""></p>
<p>Collection集合有两个重要的子接口，分别是List和Set。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List集合特点：元素有序、可重复。主要实现类：ArrayList和LinkedList。</p>
<p>List主要方法：</p>
<p><img src="../../../备份/images/noteJava/List主要方法.png" alt=""></p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>特点：在内存中线性存储。</p>
<p>优点：遍历和查找元素时非常高效。</p>
<p>缺点：增删操作时，需要移动数组，效率很低。</p>
<h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般这样用，在尖叫号内可指定数据类型</span></span><br><span class="line">List&lt;String&gt; set = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//也可以这样用：</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;stu1&quot;</span>);                    </span><br><span class="line">list.add(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;集合的长度：&quot;</span> + list.size()); </span><br><span class="line">System.out.println(<span class="string">&quot;第2个元素是：&quot;</span> + list.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//定义二维数组</span></span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line"><span class="comment">//添加数组作为元素</span></span><br><span class="line">List&lt;String&gt; subset = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">res.add(subset);</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>特点：在内存中的存储形式是双向循环链表结构，内部包含两个Node类型的first和last属性。</p>
<p>它的优缺点和ArrayList完全相反。</p>
<p>优点：增删操作效率高。缺点：遍历和查找效率低。</p>
<p>增删操作示意图：</p>
<p><img src="../../../备份/images/noteJava/LinkedList增删操作.png" alt=""></p>
<p>方法：</p>
<p><img src="../../../备份/images/noteJava/LinkedList方法1.png" alt=""></p>
<p><img src="../../../备份/images/noteJava/LinkedList方法2.png" alt=""></p>
<p>操作参考ArrayList。</p>
<h5 id="Iterator遍历集合"><a href="#Iterator遍历集合" class="headerlink" title="Iterator遍历集合"></a>Iterator遍历集合</h5><p>定义：Iterator接口是Java集合框架中的一员，主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;stu1&quot;</span>);                    </span><br><span class="line">        list.add(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line"><span class="comment">//    	这种不可以</span></span><br><span class="line"><span class="comment">//      String[] list = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span></span><br><span class="line">        Iterator iterator = list.iterator(); </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;         </span><br><span class="line">              Object obj = iterator.next();   <span class="comment">// 取出ArrayList集合中的元素</span></span><br><span class="line">              System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理</p>
<p>Iterator遍历集合时，内部采用指针的形式来跟踪集合中的元素，刚开始，指针指向第一个元素之前，即不指向任意元素，首先调用hasNext()方法，判断有没有下个元素，接着调用next()方法后，索引会往后移一位，指向某个元素并将其返回。</p>
<p><img src="../../../备份/images/noteJava/Iterator工作原理.png" alt=""></p>
<h5 id="foreach遍历集合"><a href="#foreach遍历集合" class="headerlink" title="foreach遍历集合"></a>foreach遍历集合</h5><p>foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>特点：元素无序且不重复，主要实现类：HashSet和TreeSet</p>
<h3 id="双列集合Map"><a href="#双列集合Map" class="headerlink" title="双列集合Map"></a>双列集合Map</h3><h1 id="哈希表Hashtable"><a href="#哈希表Hashtable" class="headerlink" title="哈希表Hashtable"></a>哈希表Hashtable</h1><p><a href="https://www.runoob.com/java/java-hashtable-class.html">菜鸟教程</a></p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Hashtable是原始的java.util的一部分，是一个Dictionary具体的实现，用于存储键值对。</p>
<p>为什么成为哈希表？因为键会经过哈希处理，得到一个散列码，这个散列码就是存储在该表中值的索引。</p>
<p>将哈希表作为参数传入函数后，在函数内对哈希表的操作，会影响原哈希表。</p>
<h1 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建。	</span></span><br><span class="line">Hashtable table1 = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">//存储键值对。</span></span><br><span class="line">table1.put(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//输入键返回值，若不存在返回null。</span></span><br><span class="line">table1.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//遍历所有键值对</span></span><br><span class="line">Enumeration keys1 = table1.keys();</span><br><span class="line">String key;</span><br><span class="line"><span class="keyword">while</span>(keys1.hasMoreElements()) &#123;</span><br><span class="line">	key = (String) keys1.nextElement();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;: &quot;</span> + table1.get(ch));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对某个键的值进行加1操作（若键原本不存在，则需创建）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToTable</span><span class="params">(Hashtable table, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">		Enumeration keys;</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">		<span class="keyword">int</span> value = table.getOrDefault(key, <span class="number">0</span>));</span><br><span class="line">		value ++;</span><br><span class="line">		table.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="与HashMap的区别"><a href="#与HashMap的区别" class="headerlink" title="与HashMap的区别"></a>与HashMap的区别</h2><p><a href="https://blog.csdn.net/yang13563758128/article/details/86655574">详细资料</a></p>
<blockquote>
<p>区别:  </p>
<ul>
<li><p>1.HashMap是线程不安全的，效率高，JDK1.2版本 </p>
</li>
<li><p>Hashtable是线程安全的，效率低，JDK1.0版本 </p>
</li>
<li>2.HashMap可以存储null键和null值 </li>
<li>Hashtable不可以存储null键和null值</li>
</ul>
</blockquote>
<h1 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h1><p><a href="https://www.runoob.com/java/java-enumeration-interface.html">参考资料</a></p>
<p>该接口可以枚举一个对象集合中的元素。</p>
<p>现在已经很少用了，基本被迭代器取代了。</p>
<p>实例见上面。</p>
<h1 id="遍历字符串中的每一个字符"><a href="#遍历字符串中的每一个字符" class="headerlink" title="遍历字符串中的每一个字符"></a>遍历字符串中的每一个字符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String p = <span class="string">&quot;abcd&quot;</span>;		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i ++) &#123;</span><br><span class="line"><span class="comment">//			遍历每个字符</span></span><br><span class="line">			<span class="keyword">char</span> ch = p.charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>noteMarkDown</title>
    <url>/20211119/noteMarkDown.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h1><p>格式：<img src="" alt="名称"></p>
<p>路径可以填写网络路径，也可以添加本地路径，但是，填写本地路径，并不支持绝对路径，只支持相对路径。</p>
<h1 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h1><p>格式：<a href="url">文本</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>noteLinux</title>
    <url>/20211119/noteLinux.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html">菜鸟教程</a></p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>全拼：move file，用来为文件或文件夹改名、或移到其他位置。</p>
<p>语法：<code>mv [options] src des</code></p>
<p>为文件改名：<code>mv firstname.txt secondname.txt</code></p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>网上介绍：</p>
<blockquote>
<p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
</blockquote>
<p>目前是用来创建新文件。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>notePython</title>
    <url>/20211122/notePython.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="输出格式化字符串"><a href="#输出格式化字符串" class="headerlink" title="输出格式化字符串"></a>输出格式化字符串</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/weixin_30737363/article/details/99632126">https://blog.csdn.net/weixin_30737363/article/details/99632126</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在py3.6新增的功能，<code>print</code>字符串前面加<code>f</code>表示格式化字符串，加f后可以可以在字符串里面使用<code>花括号</code>括起来表示<code>变量和表达式</code>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;format str&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;a = <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)	<span class="comment">#这里用单引号或双引号都可以，并不影响输出结果。</span></span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>py中的元组与list类似，不同之处在于元组的<code>元素不能修改</code>。</p>
<p>元组使用小括号<code>()</code>，列表使用方括号<code>[]</code>。</p>
<h1 id="json库"><a href="#json库" class="headerlink" title="json库"></a>json库</h1><h2 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads()"></a>json.loads()</h2><p>用于解码json数据。该函数返回py字段的数据类型。</p>
<p><img src="D:\myblog\备份\images\notePython\json loads.png" alt=""></p>
<p>如图，将一个长得像<code>dict</code>的<code>string</code>转换为了<code>dict</code>。</p>
<h1 id="unicode解码"><a href="#unicode解码" class="headerlink" title="unicode解码"></a>unicode解码</h1><p><a href="https://www.cnblogs.com/technologylife/p/6071787.html"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">U&quot;\u5956\u90fd\u6ca1\u62ff\u5230\u5c31\u60f3\u8981flag?&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">奖都没拿到就想要flag?</span><br></pre></td></tr></table></figure>
<h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>功能：检测子串在主串中的位置，若无，则抛出异常。（在list中也有这个方法）</p>
<p>格式：</p>
<blockquote>
<p>myStr.index(str, beg=0, end=len(string))</p>
</blockquote>
<h1 id="用wel安装第三方库"><a href="#用wel安装第三方库" class="headerlink" title="用wel安装第三方库"></a>用wel安装第三方库</h1><p><a href="https://blog.csdn.net/qq_26591517/article/details/79080787">教程</a></p>
<p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#gmpy">wel下载网站</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>noteJava</title>
    <url>/20211119/note%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多段图（动态规划题）"><a href="#多段图（动态规划题）" class="headerlink" title="多段图（动态规划题）"></a>多段图（动态规划题）</h1><p>最简单的数据结构是邻接矩阵，<a href="https://blog.csdn.net/u011212549/article/details/53423870">java参考代码</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《平凡的世界》读后感</title>
    <url>/20211119/%E3%80%8A%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>  没想到除了古侠科幻和悬疑小说外，竟然还有其他类型的小说能够让我如痴如醉。<br>  这学期刚开始，就去图书馆借来这本书。读这本书可比之前读的短篇小说集有趣多了，我在九个星期内，就把三部曲全部读完了。<br>  这本书吸引人的地方太多了，有历史教材里看不到的文革时期那段荒唐的历史、为官者处理政治的手段、平凡的人面对困境时的内心挣扎、还有刻骨铭心的爱情…..<br>  这本书给人最大的感受是，写得太现实太真实，但又不失温情。<br>  作者描绘的旧时代中国社会里，几乎所有人都在为生存挣扎，连吃饭都成了问题，所有人都在想方设法的活下去。在这种环境下，只有亲情和友情，能够让人看到生活中温暖的一面。<br>  在书中形形色色的人物中，最吸引人的当然是我们的主角孙少平和孙少安两兄弟。<br>  即使家庭是全村最贫穷的家庭，即使生活看不到出头的日子，孙少安也要跳上生活的马车，坐在驾车的位置上，绷紧全身的肌肉和神经，为一家子的生存保驾护航。<br>  他累吗？他当然累，他累得每天头一沾枕头，人就睡死过去。他苦吗？他也很苦，面对生存的压力，这个双水村有名的强人，不止一次独自落泪。但即使又苦又累，他也绝不会撒手不管家里人，因为他是家里的顶梁柱，是上至八十多岁奶奶，下至十岁出头妹妹的太阳。他深爱着这个家庭，这个家庭给了他无限的温暖和美好记忆，他愿意为了这个家庭，付出所有。<br>  再说孙少平，他跟少安一样，也是一个很能吃苦的人，同时，跟少安相比，他的思想更丰富。这得益于他在少安的扶持下，能够去读高中（相信如果少安生存压力没有那么大，能够去高中读书，他也会有更广阔的思想境界），以及和晓霞相识，形成了爱读书爱思考的好习惯。<br>  读到少平在家务农时憋得慌，想要趁年轻，到城市里去碰运气，看能不能成就一番事业这一段的时候，我不禁联想到了爸爸。想来，爸爸年轻的时候为了讨生活，到深圳去给人干苦力活，一定也跟少平一样艰辛吧。<br>  书中的润叶和晓霞让人难以忘怀。我想，如果少安能够态度坚决一点，当面回绝润叶，或许润叶就可以少受点折磨了。<br>  晓霞的死真的震惊到我了，读到她风风火火地赶往灾区报道时，我以为她会在那里出色地完成工作，根本就没想过她会出有什么生命危险，更别提她竟会死！<br>  晓霞真的是绝大部分男性的理想伴侣，美丽大方，俏皮活泼，特立独行，又有很高思想境界，同时，又对爱情忠贞。</p>
<p>  她的出现，真的是给这本沉重的作品，增添了很多鲜艳的色彩，读到她的片段，眼前总是浮现出一个活泼俏皮却又知性的形象。</p>
<p>  然而，在这朵美丽的花朵开放到最艳丽的时候，作者突然笔锋一转，让她瞬间枯萎凋零了！<br>  真的，让人意难平……<br>  后面上网查阅了作者路遥的经历，了解到作者年轻的时候家境贫寒，阶级观念根深蒂固，情路坎坷，甚至因为跟前妻身份的悬殊而没能走到最后。<br>  作者的经历跟他笔下的少平十分相似，我严重怀疑作者是以自己为模板，创造了少平这个角色。<br>  在资料中写到，有一天，作者发了一通紧急通电给兄长，让兄长赶紧去找他，兄长以为他身子出了问题，火急火燎地赶到他家，开门后，路遥痛哭流涕地对兄长说：“田晓霞死了！”。</p>
<p>​    从这件事上，就足以看出作者对田晓霞这个角色的喜爱之深。那作者为什么要把她写死呢？</p>
<p>​    这或许跟作者的经历和爱情观有关吧，尽管作者借润叶、少平之口，一再发出“爱情不因受阻于阶级”的主张，但事实又是，出生干部之家的润叶无法跟少安终成眷属，少安找了一个地道的农村姑娘作为伴侣，按这个逻辑分析下去，出生贫寒农村家庭的少平，也就更不可能跟父亲为省副书记、母亲为院长的晓霞结合了……</p>
<p>​    作者真的是个很清醒的人，他追求像晓霞这样的完美伴侣，把她送到少平身边，但却又受现实经历的影响，知道他们无法走到最后，唉……</p>
]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>专业知识</title>
    <url>/20211119/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="引擎（指在计算机领域）"><a href="#引擎（指在计算机领域）" class="headerlink" title="引擎（指在计算机领域）"></a>引擎（指在计算机领域）</h1><p>参考资料：</p>
<p>1、<a href="https://zhidao.baidu.com/question/583464440.html">https://zhidao.baidu.com/question/583464440.html</a></p>
<p>2、<a href="https://www.zhihu.com/question/278942403">https://www.zhihu.com/question/278942403</a></p>
<p>3、<a href="https://baike.baidu.com/item/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/620879?fr=aladdin">https://baike.baidu.com/item/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/620879?fr=aladdin</a></p>
<p>联想日常生活中的例子，汽车想跑起来得有引擎，飞机想飞起来也得有引擎，这里的引擎是指发动机，是上述机器的动力来源，属于最重要的部分，没有它，机器无法工作。</p>
<p>同样地，在计算机领域，引擎也是<code>最核心</code>的部分，它能够帮助用户完成<code>最基本的功能</code>，但与上面提到的发动机相比，计算机领域的引擎还存在一个<code>不一样的目的</code>：让开发者能够迅速地开发软件，而不用从零开始。从这个目的上看，个人认为，或许可以把引擎理解为<code>框架</code>。</p>
<p>如游戏引擎，内含物理引擎、音效等，用同样的引擎制作出来的软件，可能外观不相同，但内核是一样的。</p>
<p>还有微软的操作系统，说糙一点DOS就是它的引擎，windows就是同个改进DOS发展出来的。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>网络</tag>
        <tag>定义</tag>
      </tags>
  </entry>
  <entry>
    <title>文章模板</title>
    <url>/20211119/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>建站之路</title>
    <url>/20211122/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了搭建个人博客，在网上查阅了大量的资料，遇到了许多没有用过的技术或工具，一些是之前用过但是不熟练的，像git。在这期间,踩了不少坑,绕了许多弯,终于在第三天，完成了个站的创建！<a href="http://zhengjay.com">点击查看效果</a></p>
<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://www.cnblogs.com/quellanan/p/11613109.html">教程1,内附作者已配置好的主题源码</a></p>
<p>若clone作者的源码,好像得在目录输入<code>npm install</code></p>
<p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">教程2，这篇教程在关于绑定域名那块好像讲错了，建议这块换别的教程看</a></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>静态网站托管服务:github pages</p>
<p>博客模板:<code>hexo</code></p>
<p>工具:<code>git、node.js</code></p>
<h2 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h2><p>每一个github用户都能够申请一个<code>username.github.io</code>仓库，该仓库能够用于存放静态文件，任何用户都可以通过<code>https://username.github.io</code>访问你的页面，所以，可以将该功能用于<code>博客托管</code>，省了买云服务器的钱😁。</p>
<p>不过,既然是github提供的服务,那国内的用户如果没梯子没加速器,访问速度应该挺慢的吧?</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>一个专门提供<code>博客模板服务</code>的网站,有大量的模板主题可以选择.</p>
<p>我选择的是 <code>next</code>.</p>
<h1 id="下载环境"><a href="#下载环境" class="headerlink" title="下载环境"></a>下载环境</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>git是分布式版本控制系统,通过在本地运行git命令,将本地代码上传到github仓库,或者将仓库拉取到本地.</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>网上的定义是:</p>
<blockquote>
<p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
</blockquote>
<p>之前在写小程序的时候,也用到node.js.</p>
<p>但说实话,一直都是复制别人的命令来运行,没想过要去弄懂,因为觉得这东西更多的是跟开发有关,我以后又不搞开发😬</p>
<p>对了,跟node.js经常一块出现的还有<code>npm</code>,这东西是node.js的管理工具,用来安装各种扩展的.</p>
<p>关于node.js的安装,直接百度查教程就行了.</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>装完npm后,输入<code>npm install -g hexo</code>即可.</p>
<h1 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h1><h2 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH?"></a>什么是SSH?</h2><p>SSH全称Secure Shell,是建立在应用层上的安全协议,能够为通信双方的数据提供加密服务,防止中间人攻击.</p>
<p>SSH有两种级别的安全验证,一种是基于口令,这种验证安全性不高,另一种是基于密钥.</p>
<p>在对github仓库进行代码管理前,需要配置SSH密钥,只有本地拥有账户上添加的公钥对应私钥的主机,才有权限管理仓库.</p>
<h2 id="配置SSH密钥-1"><a href="#配置SSH密钥-1" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>在<code>git bash</code>输入命令<code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code>.</p>
<p>该命令将在本地生成rsa的私钥\密钥,还有一个用来记录通信主机公钥的文件:</p>
<p><img src="https://pic1.58cdn.com.cn/nowater/webim/big/n_v252713e82596a4383bc56158f385fc444.png" alt=""></p>
<p>然后在github个人首页的setting里,将公钥复制到文本框内保存.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先,配置全局用户名和邮箱:</p>
<p><code>git config --global user.name &quot;nameVal&quot;</code></p>
<p><code>git config --global user.email &quot;eamil@qq.com&quot;</code></p>
<p>输入<code>ssh -T git@github.com</code>,注意:这里不用修改邮箱.</p>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><p>在配置过程中,遇到这个bug:</p>
<p><img src="https://pic8.58cdn.com.cn/nowater/webim/big/n_v20d1a24738e604235bd610e48bed80252.png" alt=""></p>
<p>原因是在known_hosts里没有添加github的公钥,输入yes添加即可.</p>
<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><p>创建<code>blog</code>文件夹,在该目录打开git bash,输入:</p>
<p><code>hexo init</code>和<code>npm install</code></p>
<p>将自动搭建基本框架,这时,就可以本地运行看下效果了</p>
<p>先来认识一下hexo的基本命令.</p>
<h2 id="hexo基本命令"><a href="#hexo基本命令" class="headerlink" title="hexo基本命令"></a>hexo基本命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<p>可缩写为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<p>组合为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>
<h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><p>搭好框架之后,输入<code>hexo s -g</code>并可本地运行,在浏览器中输入localhost:4000查看博客.</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>默认的主题比较丑,可以上hexo官网找自己喜欢的主题,然后<code>git clone</code>到blog目录.clone下来后,根据仓库里的<code>readme.md</code>进行修改即可.</p>
<p>我选择的是<code>next</code></p>
<p>next主题的配置手册在这:<a href="http://theme-next.iissnan.com/getting-started.html#sidebar-settings">官方文档</a></p>
<p>官方的文档并不全,我还找到<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">这份</a></p>
<h2 id="hexo-bug"><a href="#hexo-bug" class="headerlink" title="hexo bug"></a>hexo bug</h2><p>在运行hexo的时候,遇到bug: The “mode” argument must be integer. Received an instance of Object</p>
<p>原因:node.js和hexo存在<code>版本适配</code>的关系,<code>将node换成低版本</code>可以解决该问题,如何换?</p>
<p>下载nvm,专门用来管理node版本的工具,<a href="https://www.jb51.net/article/202124.htm">具体看这篇教程</a></p>
<p>其他hexo上的bug,看这篇<a href="https://blog.csdn.net/as403045314/article/details/101337145">博客</a></p>
<h1 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h1><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><code>_config.yml</code>是hexo的配置文件,分为站点和主题两种,这里打开站点配置,修改<code>deploy</code>为如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: </span><br><span class="line">   github: git@github.com:username/username.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>上传很简单,输入<code>hexo d</code>即可,以后修改后要上传也是直接运行该命令就行.</p>
<p>忘了用不用在blog目录先进行git仓库的初始化了,姑且记下来:</p>
<p>git仓库初始化:<code>git init</code>.</p>
<p>关联远程仓库:<code>git remote add origin https://github.com/Zheng-Jay/Zheng-Jay.github.io.git</code></p>
<h2 id="源码备份"><a href="#源码备份" class="headerlink" title="源码备份"></a>源码备份</h2><p><code>hexo d</code>上传的文件好像跟本地文件不太一样,因此有必要进行源码的备份</p>
<p>在仓库创建save分支</p>
<p>运行<code>git push origin save</code>,运行前记得先关联远程库.</p>
<h2 id="仓库文件删除"><a href="#仓库文件删除" class="headerlink" title="仓库文件删除"></a>仓库文件删除</h2><p>顺便记下删除仓库文件的办法,在github只能删除仓库,不能删除某个文件或者文件夹,所以必须先把文件都pull到本地进行删除,再上交(这也太麻烦了吧,泪目).</p>
<p><a href="https://blog.csdn.net/weixin_42152081/article/details/80635777">参考资料</a></p>
<p>首先,拉取仓库到本地:<code>git pull origin master</code></p>
<p>在本地进行修改</p>
<p>然后输入<code>git add .</code>将修改上传到暂存区.</p>
<p>再运行<code>git commit -m &#39;del&#39;提交到本地仓库</code></p>
<p>最后,才是<code>git push origin master</code>把修改提交到origin的master分支.</p>
<h1 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>github pages给的域名<code>https://username.github.io</code>有点捞,可以上网买个,价格还可以.</p>
<p>网友推荐<code>godday</code>和<code>阿里云</code>,个人推荐阿里云.</p>
<p>一是阿里云是国内大厂,既方便,也信得过</p>
<p>二是价格便宜,同样一个域名,在godday要80元/年,而阿里云63元/年,这还用选?</p>
<h2 id="域名实名制认证"><a href="#域名实名制认证" class="headerlink" title="域名实名制认证"></a>域名实名制认证</h2><p>这应该就是传说中的<code>域名备案</code>吧</p>
<h2 id="将域名和ip进行绑定"><a href="#将域名和ip进行绑定" class="headerlink" title="将域名和ip进行绑定"></a>将域名和ip进行绑定</h2><p>这里有必要先了解下<code>A记录</code>和<code>CNAME</code>。</p>
<p>当我们拥有多个域名，并且要让它们都指向同个ip时，我们先将一个域名作为A记录与ip绑定，再让其他域名作为别名（即CNAME）指向A记录的域名上。这样，所有的域名就都指向ip了。</p>
<p>并且，当我们想要改变这些域名的指向时，只需修改A记录的指向，其他域名也会跟着它一块改变。</p>
<p>回到将我们买的域名绑定到github pages上，这时，我们需要到购买的云平台进行<code>域名解析配置</code>，将购买的域名作为<code>CNAME</code>，绑定到<code>username.github.io</code>。一共添加两条：</p>
<p><img src="https://pic5.58cdn.com.cn/nowater/webim/big/n_v20c5a61a993b24add863d108e1401dcf2.png" alt=""></p>
<p>随便记下前缀的含义：</p>
<p><img src="https://pic6.58cdn.com.cn/nowater/webim/big/n_v2df397effa26c4579867a74c2e036e655.png" alt=""></p>
<p>而我们的<code>username.github.io</code>就将作为<code>A记录</code>，指向我们的blog。</p>
<p>当然，我们还要到github进行配置，为什么？</p>
<p>假如不用在github进行配置，那么试想，是不是任何人都能将他的域名随意地指向你的域名了呢？也就是说，域名的绑定需要<code>双方同意</code>。</p>
<p>这个时候，需要到github仓库的settings里的<code>pages</code>输入购买的域名，系统将自动生成<code>CNAME</code>文件夹在根目录，完成域名的绑定！</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>文章是用<code>markdown</code>下的,用的编辑器是<code>typora</code>,要写文章,在blog文件夹输入<code>hexo new &quot;title&quot;</code>即可在<code>source/_posts</code>创建文章.</p>
<p>创建的文章带有模板,不过这里有个问题,在模板写入文章的标签,在编译的时候会报错.</p>
<p>图个方便,就复制了教程1的文章作为<code>模板</code>,以后要写,就直接复制一份进行修改就行.</p>
<p>另外,我的typora也有些问题,在写的时候输入不了中文标点符号,像是句号,顿号,都是英文的.不过这样倒方便了我在输入特殊字符的时候不用进行中英文切换.</p>
<p>markdown语法教程:</p>
<p><a href="https://www.runoob.com/markdown/md-code.html">菜鸟教程</a></p>
<p><a href="https://www.jianshu.com/p/815788f4b01d">另外一个</a></p>
<h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><h2 id="什么是SEO"><a href="#什么是SEO" class="headerlink" title="什么是SEO?"></a>什么是SEO?</h2><p>百科解释</p>
<blockquote>
<p>SEO（Search Engine Optimization）：汉译为搜索引擎优化。是一种方式：利用<a href="https://baike.baidu.com/item/搜索引擎/104812">搜索引擎</a>的规则提高网站在有关搜索引擎内的<a href="https://baike.baidu.com/item/自然排名/2092669">自然排名</a>。目的是让其在行业内占据领先地位，获得<a href="https://baike.baidu.com/item/品牌/235720">品牌</a>收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。</p>
</blockquote>
<p>说简单点,就是使我们的网站能够更容易被搜索引擎搜索爬取,从而提高流量热度.</p>
<h2 id="在搜索引擎提交我们的站点"><a href="#在搜索引擎提交我们的站点" class="headerlink" title="在搜索引擎提交我们的站点"></a>在搜索引擎提交我们的站点</h2><p>根据教程1，我们可以在<code>google</code>和<code>baidu</code>提交我们的站点，但因为我没有梯子，只能在baidu提交。</p>
<p><a href="https://ziyuan.baidu.com/site/index">https://ziyuan.baidu.com/site/index</a></p>
<p>提交前，需要验证网点是我们的，这里有三种验证方式：</p>
<p><img src="https://pic1.58cdn.com.cn/nowater/webim/big/n_v2ddd078dcc6b245be9141fcc906da5830.png" alt=""></p>
<p>这里推荐用<code>第三种</code>，第三种直接把它提供的网站在我们的云服务平台上解析下就可以了。</p>
<p>第一种我试过，把它给的文件放在public文件夹内，理论上是可以，但我怎么试都不可以。</p>
<h1 id="一些小工具"><a href="#一些小工具" class="headerlink" title="一些小工具"></a>一些小工具</h1><h2 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h2><p>这是一个博客网站访问人数和浏览人数的<code>计数小工具</code>,说是小工具,其实也就几行代码,引入脚本后调用标签就完了,非常轻量.</p>
<p>工作原理大概是这样的:</p>
<blockquote>
<p>在引入的JS(JavaScript)脚本中，会把当前页面url（或某种唯一标识）注册到其第三方服务器，服务器上保存着url与对应的计数值，点击页面后通过JS更新服务器上的计数值，并在页面初始化时在本地标签加载、显示计数值。</p>
</blockquote>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>写文章的时候用到的图片在<a href="https://www.hualigs.cn/">这里</a>上传就好了.</p>
<h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><p>就是经常在别人博客里看到的左下角的看板娘,但其实除了二次元美少女(为什么这么多人喜欢这种,而且还都是大佬…),还有其他卡通形象,如我这个:</p>
<p><img src="https://pic2.58cdn.com.cn/nowater/webim/big/n_v2bae32754b10842a1b3173f3c3f3363ad.png" alt=""></p>
<p>添加方法看这篇<a href="https://www.jianshu.com/p/5b5c61323772">blog</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然在搭建个站的过程中，遇到了许多麻烦，但了确确实实地学到了很多东西。</p>
<p>首先，是git的基本命令，算会敲了，然后对github的仓库托管也搞清楚了，这应该属于程序员的必备技能吧😋？</p>
<p>其次，是对域名解析、SSH密钥验证这些，有了一定的认识。</p>
<p>最最重要的是，以后有了一个平台来托管我的文章，促进自己的学习了！</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>hexo</tag>
        <tag>github pages</tag>
        <tag>SSH</tag>
        <tag>github命令</tag>
        <tag>绑定域名</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python处理excel数据 xlwt xlrd</title>
    <url>/20211119/%E7%94%A8Python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在学爬虫的时候，有学到用Python将爬取的数据保存在excel中，不过只是用<code>xlwt库</code>进行写操作。</p>
<p>昨天，一个<code>应用数学专业</code>同学来找我，说晚上要交期中作业，让我帮他处理点数据，数据是保存在<code>excel文件</code>，本着助人为乐的精神，帮他写了个py脚本，随便学到了如何用<code>xlwt</code>（实现写操作）和<code>xlrd</code>（实现读操作）两个第三方库处理excel文件。</p>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>其实，不止有xlwt和xlrd这两个库能够处理excel数据，只不过是我用过xlwt这个库，比较熟悉，所以就接着用了。</p>
<p>各个库对比：</p>
<p><img src="https://i.loli.net/2021/11/14/GS1VFyJrZEMgpYa.jpg" alt=""></p>
<h1 id="xls文件和xlsx文件"><a href="#xls文件和xlsx文件" class="headerlink" title="xls文件和xlsx文件"></a>xls文件和xlsx文件</h1><p>从图可以看出，我用到的库只能处理xls文件，而不能处理xlsx文件，这两种文件格式有何差别？</p>
<blockquote>
<p>文件核心结构不同：</p>
<p>xls核心结构是复合文档类型的；</p>
<p>xlsx 的核心结构是 XML 类型的结构，并且基于XML进行压缩（占用空间更小），所以也可以看做zip文件，将一个“.xlsx”文件的后缀改为ZIP后，用解压软件解压，可以看到里面有一个xml文件和文件的主要内容。</p>
</blockquote>
<blockquote>
<p>最大行列得数量不同：</p>
<p>xls最大只有65536行、256列</p>
<p>xlsx可以有1048576行、16384列</p>
</blockquote>
<p>根据网上的解释，xlsx文件能够保存的数据量更大，并且占用空间更小，毕竟是后来推出的文件格式。</p>
<p>要使用我们的xlwt和xlrd库，就得先将xlsx文件转换为xls文件，大家可以在<code>wps</code>或<code>office</code>的<code>另存为</code>中进行转换。</p>
<p>注意：xls文件最多支持256列，转换的时候要留心自己的xlsx文件列数是否超出。</p>
<h1 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install xlwt</span><br><span class="line">pip install xlrd</span><br></pre></td></tr></table></figure>
<h1 id="xlwt库"><a href="#xlwt库" class="headerlink" title="xlwt库"></a>xlwt库</h1><p>该库能够实现excel文件的写操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workbook=xlwt.Workbook(encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="comment">#创建workbook对象</span></span><br><span class="line">worksheet=workbook.add_sheet(<span class="string">&quot;sheet1&quot;</span>)<span class="comment">#创建工作表</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;hi&quot;</span>)<span class="comment">#在第0行第2列写入&quot;hi&quot;字符串</span></span><br><span class="line">workbook.save(<span class="string">&quot;myData.xls&quot;</span>)<span class="comment">#保存数据</span></span><br></pre></td></tr></table></figure>
<h1 id="xlrd库"><a href="#xlrd库" class="headerlink" title="xlrd库"></a>xlrd库</h1><p>该库能够实现excel文件的读操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   workbook = xlrd.open_workbook(<span class="string">&quot;myData.xls&quot;</span>)<span class="comment">#打开文件</span></span><br><span class="line">sheet_name = workbokk.sheet_names()<span class="comment">#获取所有sheet名称</span></span><br><span class="line">   sheet = workbook.sheet_by_index(<span class="number">0</span>)<span class="comment">#根据索引获取sheet</span></span><br><span class="line">   <span class="comment">#sheet = workbook.sheet_by_name(&#x27;shee1&#x27;)#根据名字获取sheet</span></span><br><span class="line">   <span class="comment"># sheet1的名称，行数，列数</span></span><br><span class="line"><span class="built_in">print</span>(sheet1.name, sheet1.nrows, sheet1.ncols)</span><br><span class="line"><span class="comment"># 获取整行和整列的值（数组）</span></span><br><span class="line">rows = sheet1.row_values(<span class="number">2</span>) <span class="comment"># 获取第三行内容</span></span><br><span class="line">cols = sheet1.col_values(<span class="number">0</span>) <span class="comment"># 获取第1列内容</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jingyan.baidu.com/article/1974b289c9aaefb5b0f7746b.html">excel后缀.xls和.xlsx有什么区别</a></p>
<p><a href="https://www.cnblogs.com/paul-liang/p/9187503.html"><a href="https://www.cnblogs.com/paul-liang/p/9187503.html">python处理excel总结</a></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>noteCtfCrypto</title>
    <url>/20211122/noteCtfCrypto.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>例子来源于21年新生热身赛</p>
<h2 id="题目条件"><a href="#题目条件" class="headerlink" title="题目条件"></a>题目条件</h2><p>给了一个309位的n、一个e和一个c。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要解密c，必须知道d。</p>
<p>要知道d，必须知道n的欧拉函数。</p>
<p>要知道n的欧拉函数，必须知道p，q。</p>
<h2 id="分解n"><a href="#分解n" class="headerlink" title="分解n"></a>分解n</h2><p>爆破分解几乎不可能，尝试去网上找是否有对n的分解。</p>
<p><a href="http://www.factordb.com/index.php?id=1100000001382063076">FactorDB</a></p>
<p>这是一个专门收集质质数的网站。</p>
<p>同过分解，得到p、q。</p>
<h2 id="计算欧拉函数"><a href="#计算欧拉函数" class="headerlink" title="计算欧拉函数"></a>计算欧拉函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="计算d"><a href="#计算d" class="headerlink" title="计算d"></a>计算d</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse</span><br><span class="line">d = inverse(e, phi)</span><br></pre></td></tr></table></figure>
<h2 id="解出明文"><a href="#解出明文" class="headerlink" title="解出明文"></a>解出明文</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = pow(c, d, n)</span><br></pre></td></tr></table></figure>
<p>解出来的明文是一串数字字符串，需要进行转换。</p>
<h2 id="long-to-bytes"><a href="#long-to-bytes" class="headerlink" title="long_to_bytes"></a>long_to_bytes</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>关于<code>long_to_bytes()</code>，网上没有找到资料，vscode对其解释为：</p>
<blockquote>
<p>Convert an integer to a byte string.</p>
</blockquote>
<p>目前个人的理解是，将解密出来的明文（int）作为参数，该函数将得到一个byte类型的字符串（关于byte可以去notePython查看），该字符串若是ascii编码，可以得到读得懂的信息，如：</p>
<blockquote>
<p>b’0x1337 ^ (-1) mod 0x18a39cb09e40671788a6b9221371e3f5455bbde2aff984e491c85f4f3ad309613 = ?’</p>
</blockquote>
<h2 id="模拟元"><a href="#模拟元" class="headerlink" title="模拟元"></a>模拟元</h2><p>根据提示，继续操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = inverse(<span class="number">0x1337</span>, <span class="number">0x18a39cb09e40671788a6b9221371e3f5455bbde2aff984e491c85f4f3ad309613</span>)</span><br></pre></td></tr></table></figure>
<p>同样地，得到的是一个int数据，还是调用long_to_bytes()，得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;flag&#123;456_easy_rsa_challenge_657&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="在线分解网站datadb"><a href="#在线分解网站datadb" class="headerlink" title="在线分解网站datadb"></a>在线分解网站datadb</h3><p><a href="http://www.factordb.com/index.php?id=1100000001382063076">在线分解网站datadb</a></p>
<h3 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h3><p><a href="https://blog.csdn.net/LYJ20010728/article/details/110354004">参考资料</a></p>
<p>该工具似乎解密100位左右的比较快。</p>
<p>路径已加入环境变量，直接在命令行输入<code>yafu-x64</code>即可进入程序，输入<code>factor()</code>进行分解。</p>
<p>若n的位数比较大，将n放在文本文件test.txt中（注意，最后要打个换行符），然后输入</p>
<p><code>yafu-x64 &quot;factor(@)&quot; -batchfile test.txt</code></p>
<h1 id="LCG"><a href="#LCG" class="headerlink" title="LCG"></a>LCG</h1><h2 id="概念-amp-加密算法"><a href="#概念-amp-加密算法" class="headerlink" title="概念&amp;加密算法"></a>概念&amp;加密算法</h2><p>LCG(Linear Congruential Generator, 线性同余方法)是应用广泛的<code>伪随机数生成算法</code>，递归公式：</p>
<p><code>Xn+1=(aXn+b)modn（a、b、n为参数）</code></p>
<p>将某一个秘密数字（种子，在ctf中是flag）设置为初始值X0，然后再递归地求出其他伪随机数。</p>
<p>这个算法其实就是嵌套地计算<code>仿射密码而已</code>。</p>
<h2 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h2><p><code>Xn−1=a−1(Xn−b)modn</code></p>
<p>所以，得先求出a的逆元，这个容易：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse</span><br><span class="line">r = inverse(a, n)</span><br></pre></td></tr></table></figure>
<p>然后，再写个循环即可，已写成py脚本保存。</p>
<h2 id="用C进行更快地破解"><a href="#用C进行更快地破解" class="headerlink" title="用C进行更快地破解"></a>用C进行更快地破解</h2><p>循环的次数达到2 ** 30 + 1，由于py的运行速度慢，因此有必要写个C来跑。</p>
<p><a href="https://github.com/xf1les/2019JNUCTF/blob/master/Crypto/lincoln/writeup/solve.c">代码</a></p>
<p>C用到一个叫<code>GMP</code>的开源运算库：<a href="https://gmplib.org/">官网</a></p>
<h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><h2 id="int-from-bytes"><a href="#int-from-bytes" class="headerlink" title="int.from_bytes"></a>int.from_bytes</h2><p><a href="https://blog.csdn.net/aic1999/article/details/80102433/">https://blog.csdn.net/aic1999/article/details/80102433/</a></p>
<p>将字节串转换为int类型。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.from_bytes(<span class="string">b&#x27;2&#x27;</span>, byteorder=<span class="string">&#x27;big&#x27;</span>, signed=<span class="literal">False</span>))</span><br><span class="line"><span class="comment">#49</span></span><br><span class="line"><span class="comment">#50</span></span><br></pre></td></tr></table></figure>
<p>推测这里的<code>b&#39;2&#39;</code>代表用acsii编码的’2’的字节。</p>
<h2 id="str-endswith"><a href="#str-endswith" class="headerlink" title="str.endswith"></a>str.endswith</h2><p>vscode:</p>
<blockquote>
<p>(method) endswith: (<strong>suffix: str | Tuple[str, …], </strong>start: SupportsIndex | None = …, __end: SupportsIndex | None = …) -&gt; bool</p>
<hr>
<p>S.endswith(suffix[, start[, end]]) -&gt; bool</p>
<p>Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.</p>
</blockquote>
<p>即判断字符串的结尾是否是给定的参数，是则返回true。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>文章模板</title>
    <url>/20211122/notePHP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://www.php.net/manual/zh/language.operators.array.php">官方教程</a></p>
<h1 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h1><p>sub，有替补、替代、或附属的意思。这个函数的作用是返回字符串的一部分，也就是返回一个<code>子串</code>。</p>
<p>格式：<code>substr(string, start, length)</code></p>
<p>即，string[start]开始（包含0），返回一个长度为length的子串。</p>
<h1 id="爆破seed"><a href="#爆破seed" class="headerlink" title="爆破seed"></a>爆破seed</h1><p>根据生成的已有数字序列，爆破seed。</p>
<p><a href="https://www.freebuf.com/column/205240.html">教程</a></p>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p><a href="https://www.openwall.com/php_mt_seed/">工具</a></p>
<p>在linux中直接在目录下输入<code>make</code>即可生成可执行文件。</p>
<h2 id="爆破的方法"><a href="#爆破的方法" class="headerlink" title="爆破的方法"></a>爆破的方法</h2><p>有两种，第一种是根据一串int来进行爆破，未遇到，另一种是用许多由4个数字组成一组的字符串进行爆破。</p>
<p>格式：前两个数字是随机数的结果区间，若生成的是一个确定的数，则这两个数相同，后面两个数是生成时使用的区间，注意，这四个数必须用空格隔开。</p>
<h2 id="ctf实例"><a href="#ctf实例" class="headerlink" title="ctf实例"></a>ctf实例</h2><p>该例题是21年新生杯的热身赛题目：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$all_alpha</span> = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;random_num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;random_num&#x27;</span>]=rand(<span class="number">0</span>,<span class="number">99999999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mt_srand(<span class="variable">$_SESSION</span>[<span class="string">&#x27;random_num&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$flag_len</span> = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$flag_len</span>; <span class="variable">$i</span>++ )&#123;</span><br><span class="line">    <span class="variable">$str</span>.=substr(<span class="variable">$all_alpha</span>, mt_rand(<span class="number">0</span>, strlen(<span class="variable">$all_alpha</span>) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$flag_show</span> = substr(<span class="variable">$str</span>, <span class="number">0</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;&quot;</span>.<span class="string">&#x27;我偷看到了张三的一部分flag:&#x27;</span>.<span class="variable">$flag_show</span>.<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$str</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据生成的序列，编写py脚本，获得数字在表中的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_alpha = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span></span><br><span class="line">myStr = <span class="string">&quot;8q4yXlCThvl&quot;</span></span><br><span class="line">res = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(myStr):</span><br><span class="line">    res += <span class="built_in">str</span>(all_alpha.index(ele)) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(all_alpha.index(ele)) + <span class="string">&quot; &quot;</span> + <span class="string">&quot;0 &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(all_alpha) - <span class="number">1</span>) + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>拿到索引后，再到linux，用命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./php_mt_seed 60 60 0 61 16 16 0 61 56 56 0 61 24 24 0 61 49 49 0 61 11 11 0 61 28 28 0 61 45 45 0 61 7 7 0 61 21 21 0 61 11 11 0 61</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62</span><br><span class="line">Version: 3.0.7 to 5.2.0</span><br><span class="line">Found 0, trying 0xfc000000 - 0xffffffff, speed 462.6 Mseeds/s </span><br><span class="line">Version: 5.2.1+</span><br><span class="line">Found 0, trying 0xb6000000 - 0xb7ffffff, speed 25.2 Mseeds/s </span><br><span class="line">seed = 0xb6926c12 = 3063049234 (PHP 7.1.0+)</span><br><span class="line">Found 1, trying 0xfe000000 - 0xffffffff, speed 25.4 Mseeds/s </span><br><span class="line">Found 1</span><br></pre></td></tr></table></figure>
<h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p>格式可以用：<code>echo()</code>，但echo其实不是一个<code>函数</code>，可以不带括号，直接用：<code>echo &quot;&quot;;</code></p>
<p>输出变量格式：<code>echo $param;</code></p>
<h1 id="die"><a href="#die" class="headerlink" title="die"></a>die</h1><p>格式：<code>die(message)</code></p>
<p>输出一条消息，停止当前程序，退出脚本。</p>
<p>若要输出变量的值，格式：<code>die($param)</code></p>
<p>若要输出<code>var_dump()</code>，格式：<code>die(var_dump($param))</code></p>
<p>服务端输出的message，跟<code>echo</code>能够返回给客户端。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在php中，只有数组、字典都是同一种数据结构：<code>array</code></p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$myArray</span> = <span class="keyword">array</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>);</span><br><span class="line">var_dump(<span class="variable">$myArray</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#array(3) &#123; [0]=&gt; string(5) &quot;first&quot; [1]=&gt; string(6) &quot;second&quot; [2]=&gt; string(5) &quot;third&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<p>虽然没有写明键值对，但系统还是会默认地为它创建键值对。</p>
<h2 id="指定键值对"><a href="#指定键值对" class="headerlink" title="指定键值对"></a>指定键值对</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$myArray</span> = <span class="keyword">array</span>(<span class="string">&quot;first&quot;</span> =&gt; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;second&quot;</span> =&gt; <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;third&quot;</span> =&gt; <span class="string">&quot;tomato&quot;</span>);</span><br><span class="line">var_dump(<span class="variable">$myArray</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#array(3) &#123; [&quot;first&quot;]=&gt; string(5) &quot;apple&quot; [&quot;second&quot;]=&gt; string(6) &quot;banana&quot; [&quot;third&quot;]=&gt; string(6) &quot;tomato&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的值还是数组"><a href="#数组的值还是数组" class="headerlink" title="数组的值还是数组"></a>数组的值还是数组</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span> = <span class="keyword">array</span>(<span class="number">1</span> =&gt; <span class="string">&quot;T&quot;</span>, <span class="number">0</span> =&gt;<span class="string">&quot;C&quot;</span>, <span class="number">2</span> =&gt; <span class="string">&quot;F&quot;</span>);</span><br><span class="line"><span class="variable">$post_data</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$post_data</span>[<span class="string">&#x27;b&#x27;</span>] = <span class="variable">$b</span>;</span><br></pre></td></tr></table></figure>
<h1 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h1><p>用py和php都可以传参。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>get很简单，直接在url的后面添加参数即可。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$url</span>=<span class="string">&#x27;http://localhost/test.php?param=%E6%88%91%E7%9A%84&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="variable">$html</span> = file_get_contents(<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">echo</span> <span class="variable">$html</span>;</span><br></pre></td></tr></table></figure>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p><a href="https://www.cnblogs.com/mumublog/articles/6061233.html">参考资料</a></p>
<p>post传参可以放在url中，也可以放在body中（即form），但是放在url长度有限，具体区别：</p>
<p><a href="https://www.zhihu.com/question/64312188">post放在url或body的区别</a></p>
<p>post比较麻烦，记录其中一种方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_post</span>(<span class="params"><span class="variable">$url</span>, <span class="variable">$post_data</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$postdata</span> = http_build_query(<span class="variable">$post_data</span>);</span><br><span class="line">  <span class="variable">$options</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">      <span class="string">&#x27;method&#x27;</span> =&gt; <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;header&#x27;</span> =&gt; <span class="string">&#x27;Content-type:application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;content&#x27;</span> =&gt; <span class="variable">$postdata</span>,</span><br><span class="line">      <span class="string">&#x27;timeout&#x27;</span> =&gt; <span class="number">15</span> * <span class="number">60</span> <span class="comment">// 超时时间（单位:s）</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="variable">$context</span> = stream_context_create(<span class="variable">$options</span>);</span><br><span class="line">  <span class="variable">$result</span> = file_get_contents(<span class="variable">$url</span>, <span class="literal">false</span>, <span class="variable">$context</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;http://35.229.138.83:16219?num2=9e9&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = send_post(<span class="variable">$url2</span>, <span class="variable">$post_data</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br></pre></td></tr></table></figure>
<h2 id="GET和POST同时进行"><a href="#GET和POST同时进行" class="headerlink" title="GET和POST同时进行"></a>GET和POST同时进行</h2><p>遇到一道ctf题目，既接收get请求的参数，又接收post请求的参数，对于这种，我们只需要将上面两种传参方式结合起来即可。</p>
<p>用POST传参的模板，然后在url的后面添加上要用get请求的参数。</p>
<h1 id="黑魔法"><a href="#黑魔法" class="headerlink" title="黑魔法"></a>黑魔法</h1><p>php是一门弱类型语言，在定义变量的时候不用声明它是什么类型。</p>
<p>这既给程序员编写代码带来了便利，但也产生了一些绕过，带来了很多安全问题。</p>
<h2 id="等于绕过"><a href="#等于绕过" class="headerlink" title="等于绕过"></a>等于绕过</h2><h1 id="科学计数"><a href="#科学计数" class="headerlink" title="科学计数"></a>科学计数</h1><p>格式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num2</span> = <span class="number">9e9</span>;</span><br></pre></td></tr></table></figure>
<p>ctf案例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num1</span> = <span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">if</span> (!(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num2&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;num2&#x27;</span>] &gt; <span class="variable">$num1</span> &amp;&amp; strlen(<span class="variable">$_GET</span>[<span class="string">&#x27;num2&#x27;</span>]) &lt; <span class="number">4</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Scientific notation!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题，如果用传统的计数方式传参进去，由于脚本限定了<code>$num2</code>长度最大为3，所以肯定不行。</p>
<p><code>payload:$num2 = 9e9;</code></p>
<h1 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h1><h2 id="强碰撞"><a href="#强碰撞" class="headerlink" title="强碰撞"></a>强碰撞</h2><p><a href="https://blog.csdn.net/qq_19980431/article/details/83018232">参考资料</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;md5a&#x27;</span>])||<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;md5b&#x27;</span>])||is_array(<span class="variable">$_POST</span>[<span class="string">&#x27;md5a&#x27;</span>])||is_array(<span class="variable">$_POST</span>[<span class="string">&#x27;md5b&#x27;</span>])||(<span class="variable">$_POST</span>[<span class="string">&#x27;md5a&#x27;</span>]==<span class="variable">$_POST</span>[<span class="string">&#x27;md5b&#x27;</span>])||!(md5(<span class="variable">$_POST</span>[<span class="string">&#x27;md5a&#x27;</span>]) === md5(<span class="variable">$_POST</span>[<span class="string">&#x27;md5b&#x27;</span>]))) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;no no no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，就只能去找md5相同，但字符串不同的两个字符串了。</p>
<p>产生方法：</p>
<p>使用工具<code>fastcol</code>，用法：</p>
<p><a href="https://www.cnblogs.com/hetianlab/p/14385563.html">参考资料</a></p>
<p>创建一个文本文件，写入任意的文件内容，命名为ywj.txt （源文件）</p>
<p>运行fastcoll输出以下参数。-p 是源文件，-o是输出文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fastcoll_v1.0.0.5.exe -p ywj.txt -o 1.txt 2.txt</span><br></pre></td></tr></table></figure>
<p>产生的两个文本文件里，存放的二进制数据就是我们要的，如果把它直接解码成ascii码，由于存在一些不可打印字符，因此无法直接传参，需要转换为url编码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">readmyfile</span>(<span class="params"><span class="variable">$path</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$fh</span> = fopen(<span class="variable">$path</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$data</span> = fread(<span class="variable">$fh</span>, filesize(<span class="variable">$path</span>));</span><br><span class="line">    fclose(<span class="variable">$fh</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;二进制md5加密:  &quot;</span>. md5( (readmyfile(<span class="string">&quot;1.txt&quot;</span>)));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;<span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&#x27;url编码: &#x27;</span>. urlencode(readmyfile(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;<span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;二进制md5加密: &#x27;</span>.md5( (readmyfile(<span class="string">&quot;2.txt&quot;</span>)));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;<span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&#x27;url编码: &#x27;</span>.  urlencode(readmyfile(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候，又牵扯出一个问题了，我们经过urlencode的两个字符串，需要在服务端经过一次urldecode()，而服务端只会对放在url种的参数进行urldecode，这样，我们就必须将这两个原本要post的参数放在url中。</p>
<p>那么，又出现一个问题了，放在url中的参数，如果经过浏览器传参，会被浏览器自动进行一次urlencode，这样我们就经过了两次urlencode，而在服务端只又一次urldecode。</p>
<p>所以，我们必须绕过浏览器，不让字符串再进行一次urlencode。</p>
<p>答案是用<code>curl</code></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">参考资料</a></p>
<blockquote>
<p>curl的-d参数，用于发送post请求的数据体，使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p>
</blockquote>
<p><code>payload：curl -d &#39;b[1]=T&amp;b[0]=C&amp;b[2]=F&#39; -d &#39;md5a=&amp;md5b=&#39; -X POST http://35.229.138.83:16219/?num2=9e9</code></p>
<p>这里，把post的参数放在-d后面，get参数放在url后面。</p>
<p>注意：传递的参数为数组，在win不能用，在linux可以用。</p>
<p>虽然，这里的md5a、md5b参数没有放在url后面，但是<code>Content-Type : application/x-www-form-urlencoded</code>会自动将参数放在url后面。</p>
<p>md5强碰撞：</p>
<p><code>a=%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab</code></p>
<p><code>b=%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab</code></p>
<h1 id="url传参-编码"><a href="#url传参-编码" class="headerlink" title="url传参 编码"></a>url传参 编码</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>HTTP只能传输约定的ASCII字符（即ASCII码值127以内），若要传输其他字符和一些ASCII值在127以内的特殊字符，则需要对其转义——方法是在其十六进制ASCII值前加一个%，注意约定字符也可以编码但是效果一样。URL编码的临界值为%7F（127）。</p>
<h2 id="编码范围"><a href="#编码范围" class="headerlink" title="编码范围"></a>编码范围</h2><blockquote>
<p>**RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。</p>
<p>保留字符：!$&amp;’()*+,;=😕?#[]@</p>
</blockquote>
<p>除了上述规定的字符外，其他的字符都要放在url中，都需经过编码。</p>
<p>若保留字符不是起到特殊作用，则需进行编码转移：</p>
<p><img src="../../../备份/images/notePHP/url编码字符.png" alt=""></p>
<p>注意，这里<code>%</code>也进行了编码。</p>
<h2 id="浏览器自动编码-amp-服务端解码"><a href="#浏览器自动编码-amp-服务端解码" class="headerlink" title="浏览器自动编码&amp;服务端解码"></a>浏览器自动编码&amp;服务端解码</h2><p>但这并不意味着合法字符不存在url编码，7位ascii码对应的url编码就是十六进制前加个”%”，如urlencode(‘a’) = %61，这里’a’的ascii码为97，转换为16进制便为61，这里，严格讲，应该算经过了两次编码，a通过ascii编码为61，再经过url编码为%61。</p>
<p>据龙哥说，通过url进行传参时，浏览器会自动进行一次urlencode（对%也会进行编码），服务端接收到参数时，apache会进行一次urldecode。</p>
<h2 id="py脚本对7位ascii码编码"><a href="#py脚本对7位ascii码编码" class="headerlink" title="py脚本对7位ascii码编码"></a>py脚本对7位ascii码编码</h2><p>php urlencode()不会对7位ascii码转url码，用py写了个（听说有第三方库）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">myStr = <span class="string">&quot;Longlone&quot;</span></span><br><span class="line"></span><br><span class="line">finStr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(str(hex(<span class="number">111</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in myStr:</span><br><span class="line"></span><br><span class="line">  finStr += <span class="string">&#x27;%&#x27;</span> + str(hex(ord(i)))[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(finStr)</span><br></pre></td></tr></table></figure>
<h1 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h1><p><a href="https://www.php.net/manual/zh/language.operators.array.php">参考资料</a></p>
<p>题目：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!(<span class="variable">$a</span> == <span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] <span class="keyword">and</span> <span class="variable">$a</span> !== <span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;maybe you can learn something from https://www.php.net/manual/zh/language.operators.array.php&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，要求两个数组相等但不全相等，也就是两个变量必须具有相同的键值对（相等），但是，键值对的顺序或类型不能相等。</p>
<h1 id="FILES"><a href="#FILES" class="headerlink" title="$_FILES"></a>$_FILES</h1><p><a href="http://c.biancheng.net/view/6187.html">参考资料</a></p>
<p>$_FILES是一个预定义的数组，用来获取通过post方法上次的文件的相关信息。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>noteSQL</title>
    <url>/20211124/noteSQL.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="database"><a href="#database" class="headerlink" title="database()"></a>database()</h2><p>返回当前数据库名。</p>
<h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h2><p>返回字符的编码。</p>
<h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><h2 id="延时注入（收藏的两个平台都可）"><a href="#延时注入（收藏的两个平台都可）" class="headerlink" title="延时注入（收藏的两个平台都可）"></a>延时注入（收藏的两个平台都可）</h2><p><a href="https://blog.csdn.net/ruigeling/article/details/108672859">参考资料</a></p>
<p><code>select Score from Scores where id=1 and sleep(1)</code></p>
<p>结果：</p>
<p><code>Record Count: 0; Execution Time: 1009ms</code></p>
<h1 id="闭合"><a href="#闭合" class="headerlink" title="闭合"></a>闭合</h1><p><a href="https://blog.csdn.net/qq_41631806/article/details/105453071">参考资料</a></p>
]]></content>
      <categories>
        <category>‘笔记&#39;</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ctf</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>文章模板</title>
    <url>/20211122/note%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/IT_charge/article/details/107184811">参考资料</a></p>
<p><img src="D:\myblog\备份\images\note开发者工具\Snipaste_2021-11-20_14-09-42.png" alt=""></p>
<h1 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h1><p>这部分包含<code>General</code>、<code>Response Headers</code>、<code>Request Headers</code>三部分。</p>
<h2 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h2><p>Response Headers是响应头，这部分的内容是由<code>服务器</code>填写的，里边的<code>date</code>字段是服务器的响应时间。但是，注意，这个时间的后面有<code>GMT</code>，这里的时间是<code>格林尼治时间</code>：</p>
<p><img src="D:\myblog\备份\images\note开发者工具\response date.png" alt=""></p>
<p>与北京时间的转换公式：<code>北京时间 = GMT时间 + 8小时</code></p>
<p>在ctf中，php的<code>time()</code>返回的是当前北京时间的时间戳，若需要根据响应包的时间来生成时间戳，需注意是否要转换为北京时间。</p>
<p><a href="https://tool.lu/timestamp/">时间戳在线转换工具</a></p>
<p>已编写时间转时间戳的py脚本。</p>
<h2 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h2><p>这部分内容是由客户端的浏览器填写的，告诉服务器，客户的浏览器支持什么样格式的数据。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>开发者工具</tag>
      </tags>
  </entry>
  <entry>
    <title>note正则</title>
    <url>/20211124/note%E6%AD%A3%E5%88%99.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://c.runoob.com/front-end/854/">在线工具</a></p>
<p>该工具有些语法不支持，如(?R)。</p>
<h1 id="递归-R"><a href="#递归-R" class="headerlink" title="递归(?R)"></a>递归(?R)</h1><p><a href="https://zhidao.baidu.com/question/1696866624128831108.html">教程</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ctf</tag>
        <tag>正则</tag>
      </tags>
  </entry>
</search>
